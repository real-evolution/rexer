use std::hash::Hash;

use tokio::sync::mpsc;

use crate::sink::MuxSink;
use crate::stream::MuxStream;

/// A type to multiplex tagged messages to multiple channels (streams) with the
/// tag attached to it.
#[derive(Debug)]
pub struct Mux<T, V>
where
    T: Clone + Eq + Hash,
{
    parts: MuxParts<T, V>,
}

/// The parts of a [`Mux`].
///
/// This struct is used to allow the user to consume the [`Mux`] and split it
/// into its parts more easily.
#[derive(Debug)]
pub struct MuxParts<T, V>
where
    T: Clone + Eq + Hash,
{
    /// The sink into which to send incoming tagged messages.
    pub sink: MuxSink<T, V>,

    /// The receiver from which messages generated by streams that were
    /// accepted from [`self.sink`] can be received.
    pub receiver: mpsc::Receiver<(T, V)>,

    /// Pending streams that have not yet been accepted.
    pub streams_rx: mpsc::Receiver<MuxStream<T, V>>,
}

impl<T, V> Mux<T, V>
where
    T: Clone + Eq + Hash,
{
    /// Creates a new [`Mux`] with a maximum of [`backlog`] pending streams, a
    /// buffer of [`mux_buf`] messages for unassigned messages, and a
    /// buffer of [`channel_buf`] messages for each channel.
    ///
    /// # Parameters
    /// * `backlog` - The maximum number of pending streams.
    /// * `mux_buf` - The maximum number of incoming messages that can be
    ///   buffered before waiting.
    /// * `channel_buf` - The maximum number of messages that can be buffered
    ///  per channel before waiting.
    #[inline]
    pub fn new(backlog: usize, mux_buf: usize, channel_buf: usize) -> Self {
        let (streams_tx, streams_rx) = mpsc::channel(backlog);
        let (tx, rx) = mpsc::channel(mux_buf);

        Self {
            parts: MuxParts {
                sink: MuxSink::new(channel_buf, streams_tx, tx),
                receiver: rx,
                streams_rx,
            },
        }
    }

    /// Consumes the [`Mux`] and returns its parts.
    #[inline]
    pub fn into_parts(self) -> MuxParts<T, V> {
        self.parts
    }
}
